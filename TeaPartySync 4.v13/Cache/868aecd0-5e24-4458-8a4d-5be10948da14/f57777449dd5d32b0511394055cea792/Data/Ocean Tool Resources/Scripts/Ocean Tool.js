// OceanTool.js
// Description: This script creates a ocean with split waterline view effects, user can add floating
// objects or Fluid 2D touch interaction to the surface.

/*
 * The ocean was created by vertex distortion using a noise heighmap, and the water color mapped to 
 * the height of the waves. With this technique, it can also pack the Fluid 2D texture into the height
 * to create additional touch interaction on the ocean surface.
 *
 * The split line was generated by calculating where the ocean surface postion intersecs with the
 * camera near clipping plane, and sample the water height along this intersection. The same idea
 * applies to the floating objects, the script samples the ocean height at the floating object's
 * location, with the extra help of the ocean plane bounding box sizes, it offsets the floating object
 * based on the water height.
 * 
 */

//////////////////////////////////////////////////////////////////////////////////////////////////////
////
//////////////////////////////////////////////////////////////////////////////////////////////////////

const objHelpers = require("./Modules/SceneObjectHelpersModule");

//@input bool findMainCamera = true {"label":"Find Main Camera", "hint":"When enabled, script will try to find main camera on start."}
//@input Component.Camera oceanCamera {"label":"The ocean render camera, usually the main camera used in your project.", "showIf":"findMainCamera", "showIfValue":"false"}

//@ui { "widget": "group_start", "label": "Surface" }
    //@input Asset.RenderMesh oceanMesh { "hint":"Mesh used to create an ocean surface. The higher the poly count creates more details on the surface and split line." }
    //@input bool InfiniteOcean { "hint":"Prevents going beyond the ocean plane boundary when using camera tracking, the ocean will be attached to the camera position and loop through its texture." }
    //@ui { "widget": "group_start", "label": "Transform" }
        //@input float oceanHeight = -100.0 { "label": "Ocean Height", "widget":"slider", "min":-100.0, "max":30.0, "step":0.1, "hint":"The height of the water surface." }
        //@input float oceanScale = 4.0 { "label": "Ocean Scale", "hint":"The scale of the water surface. Good value to start with will be around 2 - 15 with the given default ocean mesh" }
    //@ui { "widget": "group_end" }
//@ui { "widget": "group_end" }
//@ui { "widget": "group_start", "label": "Color" }
//@input Asset.Material surfaceMat { "label": "Surface Material" }
    //@input bool enableFoam { "hint":"Adds noise onto the crest of the ocean." }
    //@input float fbmScale = 1.0 { "label": "Foam Scale", "hint":"The noise scale of the foam pattern, larger the number the more the pattern repeats (visually appears smaller.)", "showIf":"enableFoam" }
    //@input vec4 crest { "widget":"color", "hint":"The color of the highest point on a wave." }
    //@input vec4 middle { "widget":"color", "hint":"The color of the middle point on a wave." }
    //@input vec4 trough { "widget":"color", "hint":"The color of the lowest point on a wave." }
    //@ui { "widget": "group_start", "label": "Distortion" }
        //@input Asset.Texture reflectionTex { "label": "Reflection Texture", "hint":"Water reflection, usually a screen texture." }
        //@input Asset.Texture distortionTex { "label": "Texture", "hint":"Surface reflection distortion, the R and G channel of this texture will be used as a UV offset to distort the reflection texture like a flow map." }
        //@input float distortionScale { "label": "Scale", "widget":"slider", "min":0.0, "max":10.0, "step":0.1, "hint":"Size of the distortion texture." }
        //@input float distortionIntensity { "label": "Intensity", "widget":"slider", "min":0.0, "max":10.0, "step":0.1, "hint":"Distortion weight." }
    //@ui { "widget": "group_end" }
//@ui { "widget": "group_end" }

//@ui { "widget" : "separator" }

//@ui { "widget": "group_start", "label": "Displacement" }
    //@input Asset.Material propertiesMat { "label": "Properties Material" }
    //@input float amplitude { "hint":"The vertical ​​maximum distance the ocean oscillates from its lowest (resting) point. The higher the number the taller the wave." }
    //@input float choppiness { "widget":"slider", "min":0.0, "max":6.0, "step":0.1, "hint":"Higher numbers create smaller and rougher waves." }
    //@input float norSteps { "label": "Normal Steps", "widget":"slider", "min":1.0, "max":7.0, "step": 1.0, "hint":"Detail level of the generated normal map." }
    //@input float noiseSteps { "label": "Noise Steps", "widget":"slider", "min":1.0, "max":5.0, "step": 1.0, "hint":"Detail level of the generated displacement map." }
    //@input float noiseScale { "widget":"slider", "min":0.01, "max":20.0, "step":0.1, "hint":"Size of the wave pattern." }
    //@input float speed { "widget":"slider", "min":0.0, "max":10.0, "step":0.1, "hint":"Speed of the wave animation." }
    //@input float offset { "widget":"slider", "min":0.0, "max":600.0, "step":0.1,"label": "Animation Offset", "hint":"Frame offset of the ocean animation." }
//@ui { "widget": "group_end" }

//@ui { "widget" : "separator" }

//@input bool bodyIntersection  { "hint":"When enabled, it compares view space body depth with view space ocean depth, and sort the body intersection accordingly. When disabled, the camera texture will always be in the background." }
//@input Asset.Texture bodyDepthTex { "label":"Body Depth Texture", "showIf":"bodyIntersection" }

//@ui { "widget" : "separator" }

//@input bool floatObjects
//@ui {"widget":"label", "label":"All objects assigned below need to have vertex position setup in graph to receive correct ocean height values. You can find it under the example Floaty shader."}
//@ui {"widget":"label", "label":""}
//@input SceneObject[] objectsForFloat { "showIf":"floatObjects", "hint":"The script sets material parameters to objects assigned below to control their vertex position, it offsets the position based on wave height at where the object is in space."}

//@ui { "widget" : "separator" }

//@input bool enableSplitView { "label":"Split View", "hint":"Calculate where the camera near plan intersects with the ocean surface, multiplies color onto the screen texture when it’s below the water level." }
//@ui {"widget":"group_start", "showIf" : "enableSplitView" }
    //@input float camNear = 10.0 { "label":"Camera Near", "hint":"Camera near clipping plane, decides where the split will be drawn." }
    //@input float blurFactor { "label": "Underwater Blur", "widget":"slider", "min":0.0, "max":5.0, "step":0.1, "hint":"Blur factor of the underwater section." }
    //@input vec3 underwaterTint { "label": "Underwater Tint", "widget":"color", "hint":"Color that will be multiplied onto the screen texture underwater." }
    //@input Asset.Material splitViewMat { "label":"Split View Material" }
    //@input bool enableLine { "label":"Water Line", "hint":"Draws a line along the water split surface." }
    //@input float meniscusThickness = 0.1 { "label": "Line Thickness", "widget":"slider", "min":0.0, "max":10.0, "step":0.01, "showIf":"enableLine", "hint":"Thickness of the water line." }
    //@input vec3 lineTint { "label": "Line Tint", "widget":"color", "showIf":"enableLine", "hint":"Color of the water line." }
    //@input Asset.Texture depthTarget { "hint":"Depth Render Target", "hint":"The depth value of the ocean surface will be drawn here, the shader utilized this info to retrieve the world position of the ocean to calculate its intersection with the camera near plane." }
//@ui { "widget": "group_end" }

//@ui { "widget" : "separator" }

//@input bool enableTouchInput { "label":"Touch Input", "hint":"Enable touch interaction input. An additional texture will be added to the ocean displacement calculation, based on world space touch position."}
//@input float fluidIntensity = 1.5 { "hint":"Touch input value multiplier.", "showIf":"enableTouchInput" }

//@ui { "widget" : "separator" }

//@input bool advanced
//@ui {"widget":"group_start", "label":"Properties", "showIf" : "advanced" }
    //@input Asset.Texture oceanHeightmap
    //@input float heightmapQuality { "label" : "Heightmap Quality" ,  "widget" : "combobox", "values" : [ { "label" : "Low" , "value" : "512" } , { "label" : "Mid" , "value" : "1024" } , { "label" : "High", "value" : "2048" } ], "hint":"Resolution of the displacement map."}
    //@input Asset.Texture oceanNormal
    //@input float normalQuality { "label" : "Normal Quality" ,  "widget" : "combobox", "values" : [ { "label" : "Low" , "value" : "128" } , { "label" : "Mid" , "value" : "256" } , { "label" : "High", "value" : "512" } ], "hint":"Resolution of the normal map."}
    //@input Asset.Texture screenTex { "label" : "Screen Texture" }
    //@input Asset.RenderMesh propertyMesh
    // @input Asset.Object3DAsset bodyTracking
    //@typename fluid2DSim
//@ui { "widget": "group_end" }

var depthLayer = LayerSet.makeUnique();
var mrtLayer = LayerSet.makeUnique();
var rayCastLayer = LayerSet.makeUnique();

const quatRot = quat.fromEulerAngles( 4.71239, 0.0, 0.0 );

var oceanPlane;
var oceanMeshVisual;
var worldMin;
var worldMax;
var oceanPos;
var oceanScale = script.oceanScale;
var unpackVal = new vec2 ( 0.0, script.amplitude);

global._oceanCamera = script.oceanCamera;

//////////////////////////////////////////////////////////////////////////////////////////////////////
/// Create Ocean
//////////////////////////////////////////////////////////////////////////////////////////////////////

function initialize(){
    if ( !validateInputs() ) return;
    
    createOceanPlane();
    
    if ( script.enableTouchInput ){
        // Generate fluid 2D
        script.sceneObject.createComponent( script.fluid2DSim );
    }
    
    setOceanPropertyTex();
    setOceanUniform();
}


function createOceanPlane(){
    oceanPlane = global.scene.createSceneObject("oceanPlane");
    oceanMeshVisual = oceanPlane.createComponent("Component.RenderMeshVisual");
    oceanMeshVisual.mainMaterial = script.surfaceMat;
    oceanMeshVisual.mesh = script.oceanMesh;
    
    ////////////////////////////////////////////////  
    /// World Transform
    //////////////////////////////////////////////// 
    // Controls the height transform
    oceanPos = oceanPlane.getTransform().getWorldPosition();
    oceanPos.y += script.oceanHeight;

    oceanPlane.getTransform().setWorldPosition( new vec3 ( 0.0, script.oceanHeight, 0.0 ) );
    oceanPlane.getTransform().setWorldScale( new vec3( oceanScale, oceanScale, oceanScale )  );
    
    // Get and set the aabb for highmap position sampling
    worldMin = oceanPlane.getComponent("Component.BaseMeshVisual").worldAabbMin();
    worldMax = oceanPlane.getComponent("Component.BaseMeshVisual").worldAabbMax();
    
    

    if ( script.enableTouchInput ){
    
        var bboxDiffOcean = worldMax.sub( worldMin ).uniformScale( 0.5 );
        bboxDiffOcean = Math.max( bboxDiffOcean.x, Math.max( bboxDiffOcean.y, bboxDiffOcean.z ) );
    
        var fluid2DTouchSO = global.scene.createSceneObject("fluid2DTouchSO");
        fluid2DTouchSO.getTransform().setWorldPosition( new vec3 ( 0.0, script.oceanHeight, 0.0 ) );
        
        var fluid2DTouchMeshVisual = fluid2DTouchSO.createComponent("Component.RenderMeshVisual");
        fluid2DTouchMeshVisual.clearMaterials();
        fluid2DTouchSO.layer = rayCastLayer;
        fluid2DTouchMeshVisual.mesh = script.propertyMesh;
        fluid2DTouchSO.getTransform().setWorldRotation( quatRot );
        
        var worldMinFluid = fluid2DTouchSO.getComponent("Component.BaseMeshVisual").worldAabbMin();
        var worldMaxFluid = fluid2DTouchSO.getComponent("Component.BaseMeshVisual").worldAabbMax();
        
        var bboxDiffFluid = worldMaxFluid.sub( worldMinFluid ).uniformScale( 0.5 );
        bboxDiffFluid = Math.max( bboxDiffFluid.x, Math.max( bboxDiffFluid.y, bboxDiffFluid.z ) );
    
        var scaleOffset = bboxDiffOcean / bboxDiffFluid;
        fluid2DTouchSO.getTransform().setWorldScale( new vec3( scaleOffset, scaleOffset, scaleOffset) );
    
        global._fluid2DTouchMeshVisual = fluid2DTouchMeshVisual;
    }
    
    if( script.InfiniteOcean ){
        var event = script.createEvent("UpdateEvent");
            event.bind(function(){
            // Attach ocean plan onto the camera postion to create infinite plane
            var camPos = global._oceanCamera.getTransform().getWorldPosition();
            oceanPlane.getTransform().setWorldPosition( new vec3 ( camPos.x, script.oceanHeight, camPos.z ) );
            if ( script.enableTouchInput ){
                fluid2DTouchSO.getTransform().setWorldPosition( new vec3 ( camPos.x, script.oceanHeight, camPos.z ) );
            }
        });
    }
    
}

function setOceanUniform() {
    // Ocean Noise Textures
    var propertiesPass = script.propertiesMat.mainPass;
    setOceanProperties( propertiesPass );

    // Surface color
    var surfacePass = script.surfaceMat.mainPass;
    setOceanSurface( surfacePass );

    /// Split View and Meniscus
    if ( script.enableSplitView ) {
        // Create Depth RT to get the ocean world position for split line intersection
        setdepthStencil( oceanPlane, depthLayer, global._oceanCamera );
        var meniscusPass = script.splitViewMat.mainPass;
        global._oceanCamera.near = script.camNear;
        setMeniscusValues( meniscusPass )
        createSplitView();
    }
    else{
        global._oceanCamera.near = 0.1;
    }
    
    // Floating Objects
    setFloatObjects();
    
    
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
/// Validate Inputs
//////////////////////////////////////////////////////////////////////////////////////////////////////

function setFloatObjects() {

    if( script.floatObjects ){
        for (var i = 0; i < script.objectsForFloat.length; i++) {
            // Skip if no scene object is assigned to this slot
            if (!script.objectsForFloat[i]) {
                continue;
            } else {
                componentSearchAndClone( script.objectsForFloat[i] );
            }
        }   
    }

}


function validateInputs() {
    
    if(script.findMainCamera) {
        global._oceanCamera = objHelpers.getFirstCameraIntersecting( script.getSceneObject().layer);
    }

    if ( !script.oceanCamera ) {
        print( "ERROR: Make sure main camera is set" );
        return false;
    }

    if ( !script.surfaceMat ) {
        print( "ERROR: Make sure surface ocean material is set" );
        return false;
    }
    if ( !script.reflectionTex ) {
        print( "ERROR: Make sure Reflection Texture is set" );
        return false;
    }
    if ( !script.distortionTex ) {
        print( "ERROR: Make sure Distortion Texture is set" );
        return false;
    }
    if ( !script.propertiesMat ) {
        print( "ERROR: Make sure Properties material is set" );
        return false;
    }
    if ( script.enableSplitView ) {
        if ( !script.splitViewMat ) {
            print( "ERROR: Make sure Split View material is set" );
            return false;
        }
        if ( !script.depthTarget ) {
            print( "ERROR: Make sure Depth Render Target is set" );
            return false;
        }
    }
    
    if ( !script.oceanNormal ) {
            print( "ERROR: Make sure Ocean Normal Texture is set" );
            return false;
    }
    if ( !script.oceanHeightmap ) {
            print( "ERROR: Make sure Ocean Heightmap Texture is set" );
            return false;
    }
    if ( !script.propertyMesh ) {
            print( "ERROR: Make sure to assign a plane to the property mesh" );
            return false;
    }
    
    if ( script.bodyIntersection ) {
        if ( !script.bodyDepthTex ) {
            print( "ERROR: Make sure Fluid Pressure Texture is set" );
            return false;
        }
    }

    return true;
}


////////////////////////////////////////////////  
/// Other Fonctions
//////////////////////////////////////////////// 

function setMeniscusValues( pass ){
    pass.oceanMin = worldMin;
    pass.oceanMax = worldMax;
    pass.heightmap = script.oceanHeightmap;
    pass.meniscusThickness = script.meniscusThickness;
    pass.oceanHeightmap = script.oceanHeightmap;
    pass.screenTex = script.screenTex;
    pass.depthTarget = script.depthTarget;
    pass.unpackVal = unpackVal;
    pass.oceanPos = oceanPos;
    
    pass.enableFluid = script.enableTouchInput ? 1.0 : 0.0;
    
    if (script.enableTouchInput){
        pass.fluidPressure = global._fluidPressureRT;
        pass.pressureRange = global._fluidPressureRange;
        pass.fluidMul = script.fluidIntensity;
    }

    
    ////////////////////////////////////////////////  
    // Underwater color
    ////////////////////////////////////////////////  
    
    pass.blurFactor = script.blurFactor;
    pass.underwaterTint = script.underwaterTint;
    pass.enableLine = script.enableLine == 0 ? 0.0 : 1.0;
    pass.lineTint = script.lineTint;  
}


function setOceanProperties( pass ){
    pass.choppiness = script.choppiness;
    pass.noiseSteps = script.noiseSteps;
    pass.norSteps = script.norSteps;
    pass.speed = script.speed;
    pass.offset = script.offset;
    pass.amplitude = script.amplitude;
    
    pass.enableFluid = script.enableTouchInput ? 1.0 : 0.0;
    if( script.enableTouchInput ){
        pass.fluidNormal = global._fluidNormalRT;
    }  
}


function bodyTrackingDetect(pass){
    
    var bodyTrackingObject = global.scene.createSceneObject( "ObjectTracking3D" );
    var bodyTrackingComponent = bodyTrackingObject.createComponent('Component.ObjectTracking3D');
    bodyTrackingComponent.trackingAsset = script.bodyTracking
    
    if(script.bodyIntersection){
        bodyTrackingComponent.onTrackingStarted = function(){
            pass.bodyIntersection = 1.0;
            pass.bodyDepthTex = script.bodyDepthTex;
        };
    }

    bodyTrackingComponent.onTrackingLost = function(){
        pass.bodyIntersection = 0.0;
        pass.bodyDepthTex = null;
    };
}

function setOceanSurface( pass ){
    pass.oceanMin = worldMin;
    pass.oceanMax = worldMax;
    pass.fbmScale = script.fbmScale;
    pass.oceanHeightmap = script.oceanHeightmap;
    pass.oceanNormal = script.oceanNormal;
    pass.screenTex = script.reflectionTex;
    pass.colorCrest = script.crest;
    pass.colorMiddle = script.middle;
    pass.colorTrough = script.trough;
    pass.enableFoam = script.enableFoam ? 1.0 : 0.0;
    
    pass.blurFactor = script.blurFactor;
    pass.underwaterTint = script.underwaterTint;
     
    // Reflection
    pass.distortionScale = script.distortionScale;
    pass.distortionIntensity = script.distortionIntensity;
    pass.distortionTex = script.distortionTex;
    pass.unpackVal = unpackVal;
    
    // Fluid 2D
    pass.enableFluid = script.enableTouchInput ? 1.0 : 0.0;
    
    if ( script.enableTouchInput ){
        pass.fluidPressure = global._fluidPressureRT;
        pass.pressureRange = global._fluidPressureRange;
        pass.fluidMul = script.fluidIntensity;
    } 
    
    // Body intersection
    pass.bodyIntersection = 0.0;
    pass.bodyDepthTex = null;
    bodyTrackingDetect(pass);
    
    pass.enableInfinite = script.InfiniteOcean ? 1.0 : 0.0;
}


function setFloatyValues( pass ){
    pass.oceanMin = worldMin;
    pass.oceanMax = worldMax;
    pass.unpackVal = unpackVal;
    pass.speed = script.speed;
    pass.heightmap = script.oceanHeightmap;
    pass.oceanPos = oceanPos;
    pass.enableFluid = script.enableTouchInput ? 1.0 : 0.0;
    
    if (script.enableTouchInput){
        pass.fluidPressure = global._fluidPressureRT;
        pass.pressureRange = global._fluidPressureRange;
        pass.fluidMul = script.fluidIntensity;
    }
    
    // Body intersection
    pass.bodyIntersection = 0.0;
    pass.bodyDepthTex = null;
    bodyTrackingDetect(pass);

}


function componentSearchAndClone( meshVisualObject ) {
    var objects = [];
    getComponentRecursive( meshVisualObject, "Component.RenderMeshVisual", objects );
    
    var newObjMat;
    
    for ( var i = 0; i < objects.length; i++ ) {
        var targetObject = objects[i].getSceneObject();  
        newObjMat = objects[i].mainMaterial.mainPass
        setFloatyValues( newObjMat );
    } 
}


// Walk up the hierarchy and return a scene object if a given component is found
function parentComponentSearch( srcObj, component ) {
    var foundObj = srcObj;
    if ( foundObj.getComponent( component ) ) {
        return foundObj;
    } else {
        if ( foundObj.hasParent() ) {
            return parentComponentSearch( foundObj.getParent(), component );
        } else {
            return null;
        }
    }
}


function getComponentRecursive( rootObject, component, objects ) {
    var comps = [];
    comps = rootObject.getComponents( component );
    for ( var j = 0; j < comps.length; j++ ) {
        objects.push( comps[j] );
    }
    for ( var i = 0; i < rootObject.getChildrenCount(); i++ ) {
        var children = rootObject.getChild(i);
        getComponentRecursive( children, component, objects );
    }
}


function setdepthStencil( object, layer, cam ){
    var depthStencilTexture = script.depthTarget;
    var clonedObject;
    var newObjMat;
    
    var depthCamera = global.scene.createSceneObject( "DepthCam" );
    depthCamera.setParent( cam.getSceneObject() );
    var depthCameraComponent = depthCamera.copyComponent( cam );
    depthCameraComponent.renderLayer = depthLayer;
    depthCameraComponent.renderOrder = cam.renderOrder - 100;
        
    // Create depth texture
    depthCameraComponent.renderTarget.control.msaa = false;
    depthCameraComponent.depthStencilRenderTarget.depthClearOption = DepthClearOption.CustomValue;
    depthCameraComponent.depthStencilRenderTarget.targetTexture = depthStencilTexture;
    depthCameraComponent.depthStencilRenderTarget.clearDepth = 1.0;   
    
    clonedObject = object.copySceneObject( object );
    newObjMat = object.getComponent( "Component.RenderMeshVisual" ).mainMaterial.clone();
    newObjMat.mainPass.colorMask = new vec4b( false, false, false, false );  
    clonedObject.getComponent( "Component.RenderMeshVisual" ).mainMaterial = newObjMat;
    clonedObject.layer = layer;    
    
}


function checkOrAddColorRenderTarget( colorRenderTargetsArray, colorAttachmentIndex ) {
    if ( colorAttachmentIndex >= colorRenderTargetsArray.length ) {
        for ( var i = colorRenderTargetsArray.length; i <= colorAttachmentIndex; i++ ) {
            colorRenderTargetsArray.push( Camera.createColorRenderTarget() );
        }
    }
}


// Split view post effect
function createSplitView(){
    
    var splitViewObject = global.scene.createSceneObject( "splitViewObject" );
    var splitViewComponent = splitViewObject.createComponent( "Component.PostEffectVisual" );
    splitViewComponent.renderOrder = 10000; 
    splitViewComponent.mainMaterial = script.splitViewMat; 
}


// Create heightmap and normal map
function setOceanPropertyTex(){
    // Create ocaen property plane
    var oceanPropertyObject = global.scene.createSceneObject( "oceanPropertyPlane" );
    oceanPropertyObject.getTransform().setWorldPosition( new vec3( -75.0, 20.0 - script.noiseScale, 383.0 )  );
    oceanPropertyObject.getTransform().setWorldRotation( quatRot );
    oceanPropertyObject.layer = mrtLayer;
    var oceanPropertyMeshVisual = oceanPropertyObject.createComponent( "Component.RenderMeshVisual" );
    oceanPropertyMeshVisual.mainMaterial = script.propertiesMat;
    oceanPropertyMeshVisual.mesh = script.propertyMesh;
    
    // Create MRT camera
    var mrtCamera = global.scene.createSceneObject( "MRTCam" );
    var mrtCameraComponent = mrtCamera.createComponent( "Component.Camera" );
    mrtCameraComponent.renderTarget = global._oceanCamera.renderTarget;
    mrtCameraComponent.renderLayer = mrtLayer;
    mrtCameraComponent.type = Camera.Type.Orthographic;
    mrtCameraComponent.depthBufferMode = Camera.DepthBufferMode.Regular;
    mrtCameraComponent.devicePropertyUsage = Camera.DeviceProperty.None;
    mrtCameraComponent.aspect = 1.0;  
    mrtCameraComponent.size = 15.0;  
    mrtCameraComponent.near = 1.0;
    mrtCameraComponent.far  = 1000.0;
    
    const mrtCamPos = new vec3( -75.0, 20.0 - script.noiseScale + 3.0, 383.0 );
    
    mrtCamera.getTransform().setWorldRotation( quatRot );
    mrtCamera.getTransform().setWorldPosition( mrtCamPos );
    
  // Create ocaen property RT
  if ( mrtCameraComponent ){
        
    script.oceanNormal.control.useScreenResolution = false;
    script.oceanNormal.control.resolution = new vec2( script.normalQuality, script.normalQuality );
    script.oceanHeightmap.control.useScreenResolution = false;
    script.oceanHeightmap.control.resolution = new vec2( script.heightmapQuality, script.heightmapQuality );

    var colorRenderTargets = mrtCameraComponent.colorRenderTargets;
    var targetArr = [ script.oceanHeightmap, script.oceanNormal ];
          
    for (var i = 0; i < targetArr.length; i++) {
        if ( targetArr[i] ) {
            checkOrAddColorRenderTarget( colorRenderTargets, i );
            colorRenderTargets[i].targetTexture = targetArr[i];
        }
    }
      
    mrtCameraComponent.colorRenderTargets = colorRenderTargets;
      
  }   
}


function createPostEffectForPass( material, layer ) {
    var meshSceneObj = scene.createSceneObject( "" );
    meshSceneObj.layer = layer;
    meshSceneObj.renderOrder = script.ssn_maxRenderOrder;
    script.ssn_maxRenderOrder++;
    meshSceneObj.createComponent( "PostEffectVisual" ).mainMaterial = material;
    return meshSceneObj;
}




////////////////////////////////////////////////  
/// Initialize
//////////////////////////////////////////////// 



initialize();
